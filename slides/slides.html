<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Introduction to D3</title>

    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/lib/css/github.css">

    <link rel="stylesheet" href="slides-theme/style.css" id="theme">
    <link rel="stylesheet" href="visualisations.css" id="theme">
    <link rel="stylesheet" href="css/join-demo.css">

</head>

<body>

<div class="reveal">
<div class="slides">

<section data-markdown id="0"><script type="text/template">
# Visualising Data with D3


[@timruffles](http://twitter.com/timruffles)

[SidekickJS](https://www.sidekickjs.com)


</script></section>

<section data-markdown id="1"><script type="text/template">
# Hello

- WiFi CampusGuest - no password
- https://github.com/timruffles/d3-class
- Code + slides up above - clone if you've got `git`, or grab the `.zip`.


</script></section>


<section data-markdown id="2"><script type="text/template">

## We'll be covering

<div id=venn viz=presentationTopicVenn></div>

</script></section>


<section data-markdown id="3"><script type="text/template">

## Agenda

<ul id=menu>
  <li>d3: what & why</li>
  <li>Selecting elements</li>
  <li>Binding data</li>
  <li>Scales</li>
  <li>Layouts</li>
  <li>Questions</li>
  <li>Creating your visualisations</li>
</ul>

<div viz=agenda></div>

</script></section>



<section data-markdown id="4"><script type="text/template">

## What and why of d3

</script></section>

<section data-markdown id="5"><script type="text/template">

##  What - comparison

<div id=comparisons viz=comparisons></div>

</script></section>


<section data-markdown id="6"><script type="text/template">

## Philosophy

Don't invent a propritatory API - use SVG, HTML. You'll see 'g' elements just like in SVG, not new names for old things (eg jQuery - `dataType` not `responseType`).

Toolkit for visualisations, not lots of prebaked ones.

Definitely not a charting library.

</script></section>


<section data-markdown id="7"><script type="text/template">

## Why

Not propriatory - you can use what you learn about SVG, HTML and CSS everywhere.

Mobile friendly (HTML everywhere, SVG iOS, Android Browser 3.0+).

Less to learn - not a big scary black box.

</script></section>


<section data-markdown id="8"><script type="text/template">

## Selecting elements

</script></section>


<section data-markdown id="9"><script type="text/template">

## API

<pre>
    <code>
        d3.select("body")
          .append("h2")
          .text("foo")
          .transition()
            .style("color","red");

        d3.select("p")
          .style("font-size","2em")
          .append("span")
            .text("I'm a span in a paragraph");
    </code>
</pre>

</script></section>


<section data-markdown id="10"><script type="text/template">

## Chaining

Just like jQuery, we can keep calling methods on the same elements.

If we create new elements via append, the context of our chain becomes the new elements.

Use `transition` to apply changes over time.

</script></section>


<section data-markdown id="11"><script type="text/template">

## Context

We need to be aware of which elements we're talking about

<pre>
    <code>
        // results in &lt;h2&gt;&lt;a&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/h2&gt;
        d3.select("body")
          .append("h2") // now we're in context of h2
          .append("a") // so a ends up inside h2
          .append("span"); // and span inside a

        // results in &lt;h2&gt;&lt;a&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/h2&gt;
        var h2 = d3.select("body")
          .append("h2");
        h2.append("a");
        h2.append("span");
    </code>
</pre>

</script></section>


<section data-markdown id="12"><script type="text/template">

## Events

We need to be aware of which elements we&apos;re talking about

<pre>
    <code>
        d3.selectAll("input")
          .on("change",function(data,index) {
            // event handler
          });
    </code>
</pre>

Again, very similar to jQuery, `this` being DOM element.

`d3.event` holds current event

`this` for target DOM node

</script></section>


<section data-markdown id="13"><script type="text/template">

## Code: selecting elements

</script></section>


<section data-markdown id="14"><script type="text/template">

## What are \`data\` and \`index\` doing where \`event\` is normally...?

</script></section>


<section data-markdown id="15"><script type="text/template">

## We need to talk about data

</script></section>


<section data-markdown id="16"><script type="text/template">

## Data

<ul>
  <li>d3 gets data in front of users by binding it to elements.</li>
  <li class="fragment">You can then use it to dynamically setup attributes *</li>
  <li class="fragment">It&apos;ll be passed to your event handers</li>
</ul>

</script></section>


<section data-markdown id="17"><script type="text/template">

## Joins

In the code for the comparison, before we have any data we select all divs.

Why are we binding to elements that don&apos;t exist?

<pre>
  <code>
    var sections = d3.select("#demo1")
        .append("div")
        .classed("graphs",true)
        .selectAll("div")
  </code>
</pre>

Why isn&apos;t this a waste of time?

</script></section>


<section data-markdown id="18"><script type="text/template">

## Reflecting change

Three types - new data, change in values, data leaving

<div id="change-demo" viz="reflectingChange"></div>
<button id="change-btn">Change</button>
<div id="demo-code-17">
  <pre>
    <code>
    </code>
  </pre>
</div>

</script></section>

<section data-markdown id="19"><script type="text/template">

## Update

You're setting rules for updates as soon as you bind data

Updates apply when you have both an element and a datum

Rerun the selection when adding data, attributes will be updated

Use transitions to move smoothly to the new values

<pre>
    <code>
        var update = d3.selectAll("div") // 1 div
          .data([1,2,3,4])
          // will act on the first div, passing 1
          .text(function(d) {
            return "I'm updating " + 1 // I'm updating 1
           })
    </code>
</pre>

</script></section>


<section data-markdown id="20"><script type="text/template">

## Enter

New data that doesn't fit into the current selection goes into enter

eg:

<pre>
    <code>
        var update = d3.selectAll("div") // 1 div
            .data([1,2,3,4])

        var enter = update.enter() // will act on [2,3,4], appending 3 divs
            .append("div")
    </code>
</pre>

</script></section>


<section data-markdown id="21"><script type="text/template">

## Exit

Elements that no longer have a datum will go into exit

eg:

<pre>
    <code>
        var update = d3.selectAll("div") // 5 divs
          .data([1])

        var exit = update.exit() // will affect the other 4 divs, removing them
          .remove()
    </code>
</pre>

</script></section>


<section data-markdown id="22"><script type="text/template">

## Join demo

<div id="join-demo-viz" viz="joinDemo"></div>
<div id="join-demo">
  <div class="els">
    <h2>Situation</h2>

    <h3>Elements</h3>
    <button class="addEl">Add element</button>
    <button class="removeEl">Remove element</button>
    <div class="strip" id="elements"></div>
    <h3>Data</h3>
    <button class="addData">Add data</button>
    <button class="removeData">Remove element</button>
    <div class="strip" id="data"></div>
  </div>


  <div id=contexts>
    <h2>Contexts</h2>

    <div class="context">
      <h3>Update</h3>
      <code>update context (returned by .data())</code>
      <div class="strip" id="update"></div>
    </div>
    <div class="context">
      <h3>Enter</h3>
      <code>.enter()</code>
      <div class="strip" id="enter"></div>
    </div>
    <div class="context">
      <h3>Exit</h3>
      <code>.exit()</code>
      <div class="strip" id="exit"></div>
    </div>
  </div>
</div>

</script></section>


<section data-markdown id="23"><script type="text/template">

# Code: our first data-viz

</script></section>


<section data-markdown id="24"><script type="text/template">

## Key functions

If we change data, we need a way for d3 (and us) to know it's actually referring to the same thing.

Initially datums are identified by position in array - if we change order this breaks.

Key fn tells d3 which of the values is a unique key.

</script></section>


<section data-markdown id="25"><script type="text/template">

## Creating a key function

<pre>
    <code>
        var data = [
          {"name":"jquery", data: [["dom",1], ["svg",0], ["data",0], ["open",0.7 ]]},
          {"name":"d3", data: [ ["dom",0.8], ["svg",1], ["data",1], ["open",1 ]]},
          {"name":"highcharts", data:[ ["dom",0], ["svg",1], ["data",1], ["open",0 ]]},
          {"name":"raphael", data: [["dom",0], ["svg",1], ["data",0], ["open",0.5 ]]},
          {"name":"processing", data:[ ["dom",0], ["svg",0], ["data",0.5], ["open",0.2 ]]}
        ];

        var sections = d3.select("#demo1")
          .append("div")
          .classed("graphs",true)
          .selectAll("div").data(data,function(datum) {
            return datum.name;
          });
    </code>
</pre>

</script></section>


<section data-markdown id="26"><script type="text/template">

## Hierarchy

We can reflect a hierarchical set of data in elements

<pre>
    <code>
        var sections = d3.select("#demo1")
            .append("div")
            .classed("graphs",true)
            .selectAll("div").data(data,pluck("name"))

          sections.enter()
              .append("div")
              .classed("data-framework",true)
              .append("h2")
              .text(pluck("name"))
              ;
    </code>
</pre>

In our framework comparison we had a set of frameworks each with 4 attributes.

So we need a set of 5 elements each containing 4 elements.

</script></section>


<section data-markdown id="27"><script type="text/template">

## Loading data

Don't need to include jQuery - has facilities to load CSV, JSON etc

<pre>
    <code>
        d3.csv(url,function(csv) {
          // remember to parse your data - csv is stringly typed
        });

        d3.json(url,function(tastyData) {

        });
    </code>
</pre>

</script></section>


<section data-markdown id="28"><script type="text/template">

## Munging data

d3 includes the JS 1.6 array methods - `filter`, `map`, `reduce` etc

Similar functionality to underscore.js - `nest` for `_.groupBy` etc

</script></section>


<section data-markdown id="29"><script type="text/template">

## Mins and maxes

<code>d3.extent()</code>, <code>d3.min()</code>, <code>d3.max()</code>

<pre>
    <code>
        var data = [{value: 45},{value: 10},{value: 50}];
        d3.extent(data,function(datum) {
          return datum.value
        });
        // [10,50]
    </code>
</pre>

</script></section>


<section data-markdown id="30"><script type="text/template">

## Code: sorting &amp; transitions

</script></section>


<section data-markdown id="31"><script type="text/template">

## Scales

</script></section>


<section data-markdown id="32"><script type="text/template">

## Functional scales

d3 can create our scales, so we don't need to.

<pre>
    <code>
        var mapping = d3.scale.linear()
          .domain([SMALLEST_INPUT,LARGEST_INPUT])
          .range([SMALLEST_OUTPUT,LARGEST_OUTPUT]);
    </code>
</pre>

Has built in colour scales that look lovely

</script></section>


<section data-markdown id="33"><script type="text/template">

## Ranges and domains

Domain is the range of values something has

Range is a visual representation of that domain

We map between them

</script></section>


<section data-markdown id="34"><script type="text/template">

## Domain: input, range: output

<div style="text-align: center;">
    <img src="img/scales.png" />
</div>

</script></section>


<section data-markdown id="35"><script type="text/template">

## First page menu

Simple colour scale with steps.

<pre>
    <code>
        var data = [0.05,0.1,0.1,0.1,0.1,0.1,0.45];

        // create scale
        var colors = d3.scale.linear().domain([0,data.length - 1])
        // clever inteporlation!
          .range(["#69C7FF","#3593E6"])
        // further config
          .clamp()

        d3.select("#menu").selectAll("li").data(data)
          .append("div")
          .style("background",function(d,i) { return colors(i) });
    </code>
</pre>

</script></section>


<section data-markdown id="36"><script type="text/template">

## Layouts

</script></section>


<section data-markdown id="37"><script type="text/template">

## Layouts

Pure data: they don't do the laying out for you

Most generic part of a layout is the algorithm to decide relative sizes/positions, that's what d3 gives you.

Bound to the data, accessed as if you had a `dx` and `dy` in your data.

</script></section>


<section data-markdown id="38"><script type="text/template">

## Histogram

<div id="histogram-1" viz="histogram"></div>
<div id="demo-code-37">
  <pre>
    <code>
    </code>
  </pre>
</div>

</script></section>


<section data-markdown id="39"><script type="text/template">

## Tell me and I'll forget;<br/><br/> show me and I may remember;<br /><br/> involve me and I'll understand.

</script></section>


<section data-markdown id="40"><script type="text/template">

## Hands on time

We'll be building a real-time visualisation using reddit data

Tweet your work in progress, ask me how to setup a github page to host it.

</script></section>


</div>
</div>


<script src=d3.js></script>

<!-- Code samples -->
<script src=code-samples/reflecting-change-sample.js></script>
<script src=code-samples/histogram-sample.js></script>

<!-- Visualisations -->
<script src=visualisations/venn.js></script>
<script src=visualisations/comparison-bars.js></script>
<script src=visualisations/presentation-visualisations.js></script>
<script src=visualisations/reflecting-change.js></script>
<script src=visualisations/histogram.js></script>
<script src=visualisations/join-demo.js></script>

<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>
<script>
  Reveal.initialize({

    width: "100%",

    // Display controls in the bottom right corner
    controls: false,

    // Display a presentation progress bar
    progress: true,

    // Push each slide change to the browser history
    history: true,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    center: false,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Apply a 3D roll to links on hover
    rollingLinks: false,

    // Transition style
    transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interreveal/pret Markdown in <section> elements
         { src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntareveal/x highlight for <code> elements
        { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom reveal/in and out with Alt+click
        { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speakreveal/er notes
        { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remotreveal/e control your reveal.js presentation using a touch device
        // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
    ]

  });
</script>
</body>
